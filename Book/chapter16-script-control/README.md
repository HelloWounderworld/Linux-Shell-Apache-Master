# Script Control
The Linux system allows you to control your shell scripts by using signals. The bash shell accepts signals and passes them on to any process running under the shell process. Linux signals allow you to easily kill a runaway process or temporarily pause a long-running process.

You can use the trap statement in your scripts to catch signals and perform commands. This feature provides a simple way to control whether a user can interrupt your script while it’s running.

By default, when you run a script in a terminal session shell, the interactive shell is suspended until the script completes. You can cause a script or command to run in background mode by adding an ampersand sign (&) after the command name. When you run a script or command in background mode, the interactive shell returns, allowing you to continue entering more commands. Any background processes run using this method are still tied to the terminal session. If you exit the terminal session, the background processes also exit.

To prevent this from happening, use the nohup command. This command intercepts any signals intended for the command that would stop it — for example, when you exit the terminal session. This allows scripts to continue running in background mode even if you exit the terminal session.

When you move a process to background mode, you can still control what happens to it. The jobs command allows you to view processes started from the shell session. After you know the job ID of a background process, you can use the kill command to send Linux signals to the process or use the fg command to bring the process back to the foreground in the shell session. You can suspend a running foreground process by using the Ctrl+Z key combination and place it back in background mode, using the bg command.

The nice and renice commands allow you to change the priority level of a process. By giving a process a lower priority, you allow the CPU to allocate less time to it. This comes in handy when running long processes that can take lots of CPU time.

In addition to controlling processes while they’re running, you can also determine when a process starts on the system. Instead of running a script directly from the command line interface prompt, you can schedule the process to run at an alternative time. You can accomplish this in several different ways. The at command enables you to run a script once at a preset time. The cron program provides an interface that can run scripts at a regularly scheduled interval.

Finally, the Linux system provides script fi les for you to use for scheduling your scripts to run whenever a user starts a new bash shell. Similarly, the startup fi les, such as .bashrc , are located in every user’s home directory to provide a location to place scripts and commands that run with a new shell.

In the next chapter, we look at how to write script functions. Script functions allow you to write code blocks once and then use them in multiple locations throughout your script.

## Key points:

### Handling Signals

#### Signaling the bash shell
By default, the bash shell ignores any SIGQUIT (3) and SIGTERM (15) signals it receives (so an interactive shell cannot be accidentally terminated). However, the bash shell does not ignore any SIGHUP (1) and SIGINT (2) signals it receives.

### Running Scripts in Background Mode

#### Running multiple background jobs
You must be careful when using background processes from a terminal session. Notice in the output from the ps command that each of the background processes is tied to the terminal session (pts/0) terminal. If the terminal session exits, the background process also exits.

##### Note
Earlier in this chapter we mentioned that when you attempt to exit a terminal session, a warning is issued if there are stopped processes. However, with background processes, only some terminal emulators remind you that a background job is running, before you attempt to exit the terminal session.

### Running Scripts without a Hang-Up
Because the nohup command disassociates the process from the terminal, the process loses the STDOUT and STDERR output links. To accommodate any output generated by the command, the nohup command automatically redirects STDOUT and STDERR messages to a file, called nohup.out.

##### Note
If you run another command using nohup, the output is appended to the existing nohup.out file. Be careful when running multiple commands from the same directory, because all the output is sent to the same nohup.out file, which can get confusing.

The output appears in the nohup.out fi le just as if the process ran on the command line

### Being Nice:
By default, all processes started from the shell have the same scheduling priority on the Linux system.

The scheduling priority is an integer value, from -20 (the highest priority) to +19 (the lowest priority). By default, the bash shell starts all processes with a scheduling priority of 0.

#### TIP
It’s confusing to remember that -20, the lowest value, is the highest priority and 19, the highest value, is the lowest priority. Just remember the phrase, “Nice guys finish last.” The “nicer” or higher you are in value, the lower your chance of getting the CPU.

#### Using the renice command

- You can only renice processes that you own.

- You can only renice your processes to a lower priority.

- The root user can renice any process to any priority.

If you want to fully control running processes, you must be logged in as the root account or use the sudo command.

### Running Like Clockwork

#### Scheduling a job using the at command
The atd daemon checks a special directory on the system (usually /var/spool/at) for jobs submitted using the at command.

##### Understanding the at command format
A few years ago, the batch command was another method that allowed a script to be run at a later time. The batch command was unique because you could schedule a script to run when the system was at a lower usage level. However, nowadays, the batch command is just simply a script, /usr/bin/batch, that calls the at command and submits your job to the b queue.

#### Scheduling regular scripts
The astute reader might be wondering just how you would be able to set a command to execute on the last day of every month because you can’t set the dayofmonth value to cover every month. This problem has plagued Linux and Unix programmers, and has spawned quite a few different solutions. A common method is to add an if-then statement that uses the date command to check if tomorrow’s date is 01:

    00 12 * * * if [`date +%d -d tomorrow` = 01 ] ;  then ; command

This checks every day at 12 noon to see if it’s the last day of the month, and if so, cron runs the command.
